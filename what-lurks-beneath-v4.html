<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>What Lurks Beneath</title>
<style>
  * { margin: 0; padding: 0; box-sizing: border-box; }
  html, body { width: 100%; height: 100%; overflow: hidden; background: #080603; }
  canvas { display: block; position: absolute; top: 0; left: 0; }
  #c-decomp   { z-index: 1; }
  #c-phero    { z-index: 2; }
  #c-main     { z-index: 3; }
  #c-vignette { z-index: 4; pointer-events: none; }

  #attribution {
    position: fixed; bottom: 18px; left: 50%; transform: translateX(-50%);
    z-index: 10; font-family: 'Courier New', monospace; font-size: 9px;
    line-height: 1.75; color: rgba(180,160,100,0.32); text-align: center;
    pointer-events: none; white-space: nowrap; letter-spacing: 0.08em;
  }
  #attribution .hidden  { color: rgba(110,90,50,0.16); font-style: italic; }
  #attribution .gap-line{ color: rgba(130,100,55,0.2); font-style: italic; margin-top: 3px; }
  #attribution .epoch-line{ color: rgba(80,160,120,0.4); margin-top: 4px; letter-spacing: 0.12em; }

  #audio-prompt {
    position: fixed; top: 22px; right: 24px; z-index: 10;
    font-family: 'Courier New', monospace; font-size: 9px; letter-spacing: 0.12em;
    color: rgba(160,140,80,0.4); cursor: pointer; pointer-events: all;
    transition: color 0.4s; user-select: none;
  }
  #audio-prompt:hover { color: rgba(160,200,120,0.7); }
  #audio-prompt.active { color: rgba(80,180,130,0.5); }

  #tilt-hint {
    position: fixed; top: 22px; left: 24px; z-index: 10;
    font-family: 'Courier New', monospace; font-size: 9px; letter-spacing: 0.1em;
    color: rgba(140,120,70,0.3); pointer-events: none;
    transition: opacity 1s;
  }
</style>
</head>
<body>

<canvas id="c-decomp"></canvas>
<canvas id="c-phero"></canvas>
<canvas id="c-main"></canvas>
<canvas id="c-vignette"></canvas>

<div id="audio-prompt">[ sound off ]</div>
<div id="tilt-hint">ctrl + drag to tilt &nbsp;/&nbsp; two-finger drag on mobile</div>

<div id="attribution">
  <div>model releases: huggingface.co &nbsp;|&nbsp; datacenter energy: iea.org &nbsp;|&nbsp; compute growth: epoch.ai &nbsp;|&nbsp; gpu demand: cloud pricing indices</div>
  <div class="hidden">training data volume: not publicly disclosed &nbsp;|&nbsp; daily token throughput: not publicly disclosed &nbsp;|&nbsp; real-time inference load: not publicly disclosed</div>
  <div class="gap-line">the gaps are part of the picture.</div>
  <div class="epoch-line" id="epoch-readout">compute: retrieving&hellip;</div>
</div>

<script>
(function(){
"use strict";

// ─── Canvas setup ───────────────────────────────────────────────────────────────
const dCanvas = document.getElementById('c-decomp');
const pCanvas = document.getElementById('c-phero');
const mCanvas = document.getElementById('c-main');
const vCanvas = document.getElementById('c-vignette');
const dCtx = dCanvas.getContext('2d');
const pCtx = pCanvas.getContext('2d');
const ctx   = mCanvas.getContext('2d');
const vCtx  = vCanvas.getContext('2d');

let W, H, DPR;

function resize(){
  DPR = Math.min(window.devicePixelRatio||1, 2);
  W = window.innerWidth; H = window.innerHeight;
  [dCanvas,pCanvas,mCanvas,vCanvas].forEach(c=>{
    c.width=W*DPR; c.height=H*DPR;
    c.style.width=W+'px'; c.style.height=H+'px';
  });
  [dCtx,pCtx,ctx,vCtx].forEach(c=>c.scale(DPR,DPR));
  drawVignette(); drawDecomp();
}

// ─── Perlin noise ────────────────────────────────────────────────────────────────
const PERM=new Uint8Array(512);
(()=>{
  const p=new Uint8Array(256);
  for(let i=0;i<256;i++) p[i]=i;
  for(let i=255;i>0;i--){ const j=Math.random()*(i+1)|0; [p[i],p[j]]=[p[j],p[i]]; }
  for(let i=0;i<512;i++) PERM[i]=p[i&255];
})();
const fade=t=>t*t*t*(t*(t*6-15)+10);
const lerp=(a,b,t)=>a+(b-a)*t;
const grad=(h,x,y)=>{ const v=h&3,u=v<2?x:y,w=v<2?y:x; return ((h&1)?-u:u)+((h&2)?-w:w); };
function noise2(x,y){
  const xi=Math.floor(x)&255, yi=Math.floor(y)&255;
  const xf=x-Math.floor(x), yf=y-Math.floor(y);
  const u=fade(xf), v=fade(yf);
  const a=PERM[xi]+yi, b=PERM[xi+1]+yi;
  return lerp(lerp(grad(PERM[a],xf,yf),grad(PERM[b],xf-1,yf),u),
              lerp(grad(PERM[a+1],xf,yf-1),grad(PERM[b+1],xf-1,yf-1),u),v);
}

// ─── 3D Perspective ─────────────────────────────────────────────────────────────
// Camera orientation stored as euler angles (rotX, rotY)
// rotX: tilt forward/back  rotY: rotate left/right
// Z world range: -DEPTH/2 to +DEPTH/2  (negative = deeper underground)
const DEPTH = 600;          // total Z range in world units
const FOV_DIST = 900;       // perspective focal length

let camRotX = 0.0;          // current tilt (radians)
let camRotY = 0.0;
let targetRotX = 0.0;       // smoothed target
let targetRotY = 0.0;
const MAX_TILT = 1.05;      // max tilt angle ~60deg

// Project world (x,y,z) → screen (sx,sy,scale)
// World origin = centre of screen at z=0
function project(wx, wy, wz){
  // Guard against NaN inputs
  if(!isFinite(wx)||!isFinite(wy)||!isFinite(wz)) return null;
  const cy=Math.cos(camRotY), sy2=Math.sin(camRotY);
  const cx=Math.cos(camRotX), sx=Math.sin(camRotX);
  const dx=wx-W/2, dy=wy-H/2, dz=wz;
  const rx1= dx*cy + dz*sy2;
  const ry1= dy;
  const rz1=-dx*sy2 + dz*cy;
  const rx2= rx1;
  const ry2= ry1*cx - rz1*sx;
  const rz2= ry1*sx + rz1*cx;
  const denom = FOV_DIST + rz2;
  if(denom < 1) return null;
  const scale = FOV_DIST / denom;
  const sx2 = W/2 + rx2*scale;
  const sy2b = H/2 + ry2*scale;
  // Final finite check
  if(!isFinite(sx2)||!isFinite(sy2b)||!isFinite(scale)) return null;
  return { sx: sx2, sy: sy2b, scale, depth: rz2 };
}

// Depth-based alpha/brightness modifier
function depthFog(depth){
  // depth roughly -300..+300 after rotation
  // objects further away (more positive depth after rotation) get dimmer
  const t = Math.max(0, Math.min(1, (depth + DEPTH*0.5) / DEPTH));
  return 1 - t*0.75; // 1.0 near, 0.25 far
}

// ─── Epoch data ──────────────────────────────────────────────────────────────────
const EPOCH_DATA=[
  {year:1959,model:'Perceptron',logflop:7},
  {year:1986,model:'Backprop NNs',logflop:12},
  {year:1998,model:'LeNet-5',logflop:13},
  {year:2012,model:'AlexNet',logflop:18},
  {year:2014,model:'GoogLeNet',logflop:20},
  {year:2016,model:'ResNet',logflop:21},
  {year:2017,model:'Transformer',logflop:22},
  {year:2018,model:'BERT',logflop:23},
  {year:2019,model:'GPT-2',logflop:23.5},
  {year:2020,model:'GPT-3',logflop:23.6},
  {year:2021,model:'Gopher',logflop:24},
  {year:2022,model:'Chinchilla',logflop:23.8},
  {year:2022,model:'PaLM',logflop:24.7},
  {year:2023,model:'GPT-4 (est.)',logflop:25.3},
  {year:2023,model:'LLaMA-2',logflop:24.5},
  {year:2024,model:'Gemini Ultra',logflop:25.5},
  {year:2024,model:'Claude 3 Opus',logflop:25.4},
  {year:2025,model:'Frontier (est.)',logflop:26},
];
let epochGrowthRate=1.0;
function processEpochData(){
  const baseline=EPOCH_DATA.find(d=>d.year===2017).logflop;
  const latest=EPOCH_DATA[EPOCH_DATA.length-1];
  const doublings=(latest.logflop-baseline)/Math.log10(2);
  epochGrowthRate=1+doublings*0.015;
  document.getElementById('epoch-readout').textContent=
    `epoch.ai · training compute × 2^${doublings.toFixed(1)} since transformer baseline (2017)`;
}
processEpochData();

// ─── Decomp & vignette ───────────────────────────────────────────────────────────
function drawDecomp(){
  dCtx.clearRect(0,0,W,H);
  for(let i=0;i<150;i++){
    const x=Math.random()*W, y=Math.random()*H;
    const r=18+Math.random()*95;
    const n=noise2(x*0.008,y*0.008);
    const grd=dCtx.createRadialGradient(x,y,0,x,y,r);
    if(n>0){ grd.addColorStop(0,`rgba(75,38,8,${0.06+Math.random()*0.07})`); grd.addColorStop(0.5,`rgba(50,22,6,${0.03+Math.random()*0.04})`); }
    else    { grd.addColorStop(0,`rgba(35,50,15,${0.04+Math.random()*0.05})`); grd.addColorStop(0.5,`rgba(18,32,8,${0.02+Math.random()*0.03})`); }
    grd.addColorStop(1,'rgba(0,0,0,0)');
    dCtx.save(); dCtx.translate(x,y); dCtx.rotate(Math.random()*Math.PI*2); dCtx.scale(1,0.35+Math.random()*0.9);
    dCtx.beginPath(); dCtx.arc(0,0,r,0,Math.PI*2); dCtx.restore();
    dCtx.fillStyle=grd; dCtx.fill();
  }
  for(let i=0;i<4000;i++){
    const x=Math.random()*W, y=Math.random()*H;
    dCtx.fillStyle=`rgba(85,55,18,${0.012+Math.random()*0.025})`; dCtx.fillRect(x,y,1,1);
  }
}
function drawVignette(){
  vCtx.clearRect(0,0,W,H);
  const g=vCtx.createRadialGradient(W/2,H/2,Math.min(W,H)*0.22,W/2,H/2,Math.max(W,H)*0.88);
  g.addColorStop(0,'rgba(0,0,0,0)'); g.addColorStop(0.6,'rgba(4,2,1,0.35)'); g.addColorStop(1,'rgba(4,2,1,0.88)');
  vCtx.fillStyle=g; vCtx.fillRect(0,0,W,H);
}

// ─── Pheromone canvas ────────────────────────────────────────────────────────────
function fadePheroCanvas(){ pCtx.fillStyle='rgba(8,6,3,0.011)'; pCtx.fillRect(0,0,W,H); }
function depositPheromone(x,y,strength){
  if(!isFinite(x)||!isFinite(y)) return;
  const r=5+strength*8;
  const g=pCtx.createRadialGradient(x,y,0,x,y,r);
  const a=0.06+strength*0.12;
  g.addColorStop(0,`rgba(180,110,20,${a})`); g.addColorStop(0.4,`rgba(140,80,12,${a*0.5})`); g.addColorStop(1,'rgba(0,0,0,0)');
  pCtx.fillStyle=g; pCtx.beginPath(); pCtx.arc(x,y,r,0,Math.PI*2); pCtx.fill();
}

// ─── Mycelium strands ─────────────────────────────────────────────────────────────
const strands=[];
const MAX_STRANDS=300;
const MAX_LEN=240;

class Strand {
  constructor(x,y,z,angle,angleZ,energy,parent){
    this.nodes=[{x,y,z}];   // 3D nodes
    this.angle=angle;         // XY angle
    this.angleZ=angleZ;       // Z drift angle
    this.energy=energy;
    this.age=0; this.alive=true; this.parent=parent||null;
    this.noiseOff=Math.random()*1000;
    this.thickness=0.3+energy*1.6;
    this.branchCooldown=6+Math.random()*22;
    this.droop=0.001+Math.random()*0.007;
    this.chaos=0.25+Math.random()*0.35;
    this.zDrift=(Math.random()-0.5)*0.018; // slow Z drift
  }
  tip(){ return this.nodes[this.nodes.length-1]; }
  grow(){
    if(!this.alive) return;
    const t=this.tip();
    const n1=noise2(t.x*0.004+this.noiseOff,   t.y*0.004+this.noiseOff*0.7);
    const n2=noise2(t.x*0.012+this.noiseOff*2, t.y*0.012);
    this.angle+=(n1*0.3+n2*this.chaos)+this.droop*Math.sin(this.angle+Math.PI*0.5);
    this.angleZ+=this.zDrift+noise2(t.z*0.05+this.noiseOff*0.3, t.x*0.005)*0.04;
    const speed=(1.0+Math.random()*0.8)*epochGrowthRate;
    const nx=t.x+Math.cos(this.angle)*speed;
    const ny=t.y+Math.sin(this.angle)*speed;
    const rawNz=t.z+Math.sin(this.angleZ)*speed*0.4;
    const nz=Math.max(-DEPTH*0.48, Math.min(DEPTH*0.48, isFinite(rawNz)?rawNz:t.z));
    this.nodes.push({x:isFinite(nx)?nx:t.x, y:isFinite(ny)?ny:t.y, z:nz});
    this.age++; this.branchCooldown--;
    if(this.branchCooldown<=0&&strands.length<MAX_STRANDS){
      const bc=(0.07+this.energy*0.05)*epochGrowthRate;
      if(Math.random()<bc){
        const side=Math.random()<0.65?1:-1;
        const spread=0.6+Math.random()*1.2;
        const zSpread=(Math.random()-0.5)*0.4;
        strands.push(new Strand(nx,ny,nz, this.angle+side*spread, this.angleZ+zSpread, this.energy*(0.45+Math.random()*0.3), this));
        this.branchCooldown=12+Math.random()*28;
      }
    }
    if(this.age>MAX_LEN||this.energy<0.015) this.alive=false;
    this.energy*=0.9994;
    if(nx<-60||nx>W+60||ny<-60||ny>H+60) this.alive=false;
  }
}

function spawnStrand(){
  let x,y,angle;
  const r=Math.random();
  if(r<0.38){ x=W/2+(Math.random()-0.5)*W*0.35; y=H/2+(Math.random()-0.5)*H*0.35; angle=Math.random()*Math.PI*2; }
  else if(r<0.65){ x=Math.random()*W; y=H*0.55+Math.random()*H*0.45; angle=-Math.PI/2+(Math.random()-0.5)*1.4; }
  else { x=Math.random()*W; y=Math.random()*H; angle=Math.random()*Math.PI*2; }
  const z=(Math.random()-0.5)*DEPTH*0.7;
  strands.push(new Strand(x,y,z,angle,(Math.random()-0.5)*0.5, 0.45+Math.random()*0.55));
}
for(let i=0;i<20;i++) spawnStrand();

// ─── Spores ───────────────────────────────────────────────────────────────────────
const spores=[];
class Spore {
  constructor(x,y,z,e){
    this.x=x; this.y=y; this.z=z;
    this.vx=(Math.random()-0.5)*0.7;
    this.vy=-0.2-Math.random()*1.1;
    this.vz=(Math.random()-0.5)*0.5;
    this.life=1; this.decay=0.005+Math.random()*0.009;
    this.r=0.8+Math.random()*2.2;
    this.hue=Math.random()<0.4?'180,220,80':'55,195,175';
  }
  update(){
    this.x+=this.vx; this.y+=this.vy; this.z+=this.vz;
    this.vy*=0.994;
    this.vx+=noise2(this.x*0.025,this.y*0.025)*0.05;
    this.life-=this.decay;
  }
}

// ─── Leaf fragments ───────────────────────────────────────────────────────────────
function makeLeafPoints(size,jagged){
  const pts=[]; const segs=8;
  for(let i=0;i<=segs;i++){
    const t=i/segs; const angle=t*Math.PI;
    const w=size*0.45*Math.sin(angle); const base_y=-(t-0.5)*size;
    const jitter=jagged?(Math.random()-0.5)*size*0.18:0;
    pts.push({x:w+jitter,y:base_y+jitter*0.3});
  }
  for(let i=segs;i>=0;i--){
    const t=i/segs; const angle=t*Math.PI;
    const w=-size*0.45*Math.sin(angle); const base_y=-(t-0.5)*size;
    const jitter=jagged?(Math.random()-0.5)*size*0.18:0;
    pts.push({x:w+jitter,y:base_y+jitter*0.3});
  }
  return pts;
}
const LEAF_VARIANTS=[];
for(let i=0;i<8;i++) LEAF_VARIANTS.push(makeLeafPoints(5+Math.random()*3,true));
function drawLeaf(ctx2,leafIdx,x,y,angle,alpha){
  const pts=LEAF_VARIANTS[leafIdx%LEAF_VARIANTS.length];
  ctx2.save(); ctx2.translate(x,y); ctx2.rotate(angle);
  ctx2.beginPath(); ctx2.moveTo(pts[0].x,pts[0].y);
  for(let p of pts) ctx2.lineTo(p.x,p.y);
  ctx2.closePath();
  ctx2.fillStyle=`rgba(120,170,40,${alpha*0.85})`; ctx2.fill();
  ctx2.beginPath(); ctx2.moveTo(0,-5); ctx2.lineTo(0,5);
  ctx2.strokeStyle=`rgba(80,130,20,${alpha*0.6})`; ctx2.lineWidth=0.5; ctx2.stroke();
  ctx2.restore();
}

// ─── Ants ─────────────────────────────────────────────────────────────────────────
const ants=[];
const ANT_COUNT=58;
const pheromones=[];

class Ant {
  constructor(){
    const side=Math.random()*4|0;
    if(side===0){ this.x=Math.random()*W; this.y=H+12; }
    else if(side===1){ this.x=Math.random()*W; this.y=-12; }
    else if(side===2){ this.x=-12; this.y=Math.random()*H; }
    else { this.x=W+12; this.y=Math.random()*H; }
    this.z=(Math.random()-0.5)*DEPTH*0.5; // ants distributed through Z space
    this.angle=Math.atan2(H/2-this.y,W/2-this.x);
    this.speed=0.75+Math.random()*0.8;
    this.targetStrand=null;
    this.wobble=Math.random()*100;
    this.leafVariant=Math.floor(Math.random()*LEAF_VARIANTS.length);
    this.leafAngle=Math.random()*Math.PI*2;
    this.hasLeaf=true;
    this.depositCooldown=0;
    this.zDrift=(Math.random()-0.5)*0.3; // slow Z drift
  }
  update(tick){
    this.wobble+=0.18;
    const n=noise2(this.x*0.009+tick*0.0008,this.y*0.009-tick*0.0006);
    this.angle+=n*0.16+(Math.random()-0.5)*0.06;
    // Slow Z drift
    this.z+=this.zDrift+noise2(this.z*0.03+tick*0.001,this.x*0.004)*0.08;
    this.z=Math.max(-DEPTH*0.5, Math.min(DEPTH*0.5, this.z));

    // Seek — prefer targets at similar Z depth
    if(!this.targetStrand||!this.targetStrand.alive){
      let best=null, bestScore=-Infinity;
      for(let s of strands){
        if(s.nodes.length<3) continue;
        const t=s.tip();
        const d2D=dist2D(this.x,this.y,t.x,t.y);
        const dZ=Math.abs(this.z-t.z);
        const score=s.energy*120 - d2D - dZ*0.3;
        if(score>bestScore){ bestScore=score; best=s; }
      }
      this.targetStrand=best;
    }
    if(this.targetStrand){
      const t=this.targetStrand.tip();
      const da=angleTo(this.x,this.y,t.x,t.y);
      const diff=angleDiff(da,this.angle);
      this.angle+=diff*0.055;
      // Drift Z toward target Z
      this.z+=(t.z-this.z)*0.008;
      if(dist2D(this.x,this.y,t.x,t.y)<9&&this.depositCooldown<=0){
        this.targetStrand.energy=Math.min(1,this.targetStrand.energy+0.09);
        if(Math.random()<0.35) spores.push(new Spore(t.x,t.y,t.z,this.targetStrand.energy));
        pheromones.push({x:this.x,y:this.y,z:this.z,str:0.9});
        depositPheromone(this.x,this.y,0.9);
        this.depositCooldown=80+Math.random()*60;
        this.targetStrand=null;
        if(audioReady) triggerDepositClick();
      }
    }
    if(this.depositCooldown>0) this.depositCooldown--;

    // Pheromone steering
    let px=0,py=0,pt=0;
    for(let p of pheromones){
      const d=dist2D(this.x,this.y,p.x,p.y);
      const dz=Math.abs(this.z-p.z);
      if(d<50&&d>0&&dz<80){ const w=p.str/d; px+=(p.x-this.x)*w; py+=(p.y-this.y)*w; pt+=w; }
    }
    if(pt>0){ const pa=Math.atan2(py,px); this.angle+=angleDiff(pa,this.angle)*0.014; }
    if(Math.random()<0.06) depositPheromone(this.x,this.y,0.15);

    this.x+=Math.cos(this.angle)*this.speed;
    this.y+=Math.sin(this.angle)*this.speed;
    this.leafAngle+=0.01;
    if(this.x<-25) this.x=W+25;
    if(this.x>W+25) this.x=-25;
    if(this.y<-25) this.y=H+25;
    if(this.y>H+25) this.y=-25;
  }
}

function dist2D(ax,ay,bx,by){ const dx=bx-ax,dy=by-ay; return Math.sqrt(dx*dx+dy*dy); }
function angleTo(ax,ay,bx,by){ return Math.atan2(by-ay,bx-ax); }
function angleDiff(a,b){ let d=a-b; while(d>Math.PI)d-=Math.PI*2; while(d<-Math.PI)d+=Math.PI*2; return d; }

for(let i=0;i<ANT_COUNT;i++) ants.push(new Ant());

// ─── Mouse / touch / tilt controls ───────────────────────────────────────────────
let mouseX=-9999, mouseY=-9999;
let ctrlHeld=false, tiltDragging=false;
let tiltDragLastX=0, tiltDragLastY=0;

// Keyboard
window.addEventListener('keydown',e=>{ if(e.key==='Control'||e.key==='Meta') ctrlHeld=true; });
window.addEventListener('keyup',  e=>{ if(e.key==='Control'||e.key==='Meta'){ ctrlHeld=false; tiltDragging=false; } });

// Mouse
mCanvas.addEventListener('mousemove',e=>{
  if(ctrlHeld){
    if(tiltDragging){
      const dx=e.clientX-tiltDragLastX;
      const dy=e.clientY-tiltDragLastY;
      targetRotY+=dx*0.006;
      targetRotX+=dy*0.006;
      targetRotX=Math.max(-MAX_TILT,Math.min(MAX_TILT,targetRotX));
      targetRotY=Math.max(-MAX_TILT,Math.min(MAX_TILT,targetRotY));
    }
    tiltDragLastX=e.clientX; tiltDragLastY=e.clientY;
    tiltDragging=true;
  } else {
    tiltDragging=false;
    mouseX=e.clientX; mouseY=e.clientY;
  }
});
mCanvas.addEventListener('mousedown',e=>{ if(ctrlHeld){ tiltDragging=true; tiltDragLastX=e.clientX; tiltDragLastY=e.clientY; } });
mCanvas.addEventListener('mouseup',()=>{ tiltDragging=false; });
mCanvas.addEventListener('mouseleave',()=>{ mouseX=-9999; mouseY=-9999; tiltDragging=false; });

// Touch — two finger = tilt, one finger = normal
let lastTouchDist=0, lastTouchMidX=0, lastTouchMidY=0;
let twoFingerActive=false;

mCanvas.addEventListener('touchstart',e=>{
  if(e.touches.length===2){
    twoFingerActive=true;
    lastTouchMidX=(e.touches[0].clientX+e.touches[1].clientX)/2;
    lastTouchMidY=(e.touches[0].clientY+e.touches[1].clientY)/2;
  }
},{passive:false});

mCanvas.addEventListener('touchmove',e=>{
  e.preventDefault();
  if(e.touches.length===2){
    twoFingerActive=true;
    const midX=(e.touches[0].clientX+e.touches[1].clientX)/2;
    const midY=(e.touches[0].clientY+e.touches[1].clientY)/2;
    const dx=midX-lastTouchMidX;
    const dy=midY-lastTouchMidY;
    targetRotY+=dx*0.007;
    targetRotX+=dy*0.007;
    targetRotX=Math.max(-MAX_TILT,Math.min(MAX_TILT,targetRotX));
    targetRotY=Math.max(-MAX_TILT,Math.min(MAX_TILT,targetRotY));
    lastTouchMidX=midX; lastTouchMidY=midY;
  } else if(e.touches.length===1&&!twoFingerActive){
    mouseX=e.touches[0].clientX; mouseY=e.touches[0].clientY;
  }
},{passive:false});

mCanvas.addEventListener('touchend',e=>{
  if(e.touches.length<2) twoFingerActive=false;
  if(e.touches.length===0){ mouseX=-9999; mouseY=-9999; }
},{passive:false});

// Double-click to reset tilt
mCanvas.addEventListener('dblclick',()=>{
  targetRotX=0; targetRotY=0;
});

// ─── Audio ─────────────────────────────────────────────────────────────────────
let audioCtx=null,masterGain=null,audioEnabled=false,audioReady=false;
function buildAudio(){
  try{
    audioCtx=new(window.AudioContext||window.webkitAudioContext)();
    masterGain=audioCtx.createGain(); masterGain.gain.setValueAtTime(0,audioCtx.currentTime);
    masterGain.connect(audioCtx.destination);
    const osc1=audioCtx.createOscillator(); osc1.type='sine'; osc1.frequency.value=36.7;
    const g1=audioCtx.createGain(); g1.gain.value=0.18; osc1.connect(g1); g1.connect(masterGain); osc1.start();
    const osc2=audioCtx.createOscillator(); osc2.type='sine'; osc2.frequency.value=55.2;
    const g2=audioCtx.createGain(); g2.gain.value=0.09; osc2.connect(g2); g2.connect(masterGain); osc2.start();
    const osc3=audioCtx.createOscillator(); osc3.type='sine'; osc3.frequency.value=128.4;
    const g3=audioCtx.createGain(); g3.gain.value=0.04; osc3.connect(g3); g3.connect(masterGain); osc3.start();
    const bufLen=audioCtx.sampleRate*3;
    const buf=audioCtx.createBuffer(1,bufLen,audioCtx.sampleRate);
    const data=buf.getChannelData(0); for(let i=0;i<bufLen;i++) data[i]=Math.random()*2-1;
    const noise=audioCtx.createBufferSource(); noise.buffer=buf; noise.loop=true;
    const lpf=audioCtx.createBiquadFilter(); lpf.type='lowpass'; lpf.frequency.value=90; lpf.Q.value=1.8;
    const ng=audioCtx.createGain(); ng.gain.value=0.06;
    noise.connect(lpf); lpf.connect(ng); ng.connect(masterGain); noise.start();
    const lfo=audioCtx.createOscillator(); lfo.type='sine'; lfo.frequency.value=0.08;
    const lfoG=audioCtx.createGain(); lfoG.gain.value=1.5; lfo.connect(lfoG); lfoG.connect(osc2.frequency); lfo.start();
    const lfo2=audioCtx.createOscillator(); lfo2.type='sine'; lfo2.frequency.value=0.024;
    const lfoG2=audioCtx.createGain(); lfoG2.gain.value=0.5; lfo2.connect(lfoG2); lfoG2.connect(osc1.frequency); lfo2.start();
    audioReady=true; return true;
  }catch(e){ return false; }
}
function enableAudio(){
  if(!audioCtx&&!buildAudio()) return;
  if(audioCtx.state==='suspended') audioCtx.resume();
  audioEnabled=true;
  masterGain.gain.linearRampToValueAtTime(0.55,audioCtx.currentTime+3.5);
  document.getElementById('audio-prompt').textContent='[ sound on ]';
  document.getElementById('audio-prompt').classList.add('active');
}
function disableAudio(){
  audioEnabled=false;
  if(masterGain) masterGain.gain.linearRampToValueAtTime(0,audioCtx.currentTime+1.5);
  document.getElementById('audio-prompt').textContent='[ sound off ]';
  document.getElementById('audio-prompt').classList.remove('active');
}
function triggerDepositClick(){
  if(!audioReady||!audioEnabled) return;
  try{
    const o=audioCtx.createOscillator(); const g=audioCtx.createGain();
    const freqs=[73.4,110,146.8,183.5];
    o.frequency.value=freqs[Math.floor(Math.random()*freqs.length)]; o.type='sine';
    g.gain.setValueAtTime(0,audioCtx.currentTime);
    g.gain.linearRampToValueAtTime(0.04,audioCtx.currentTime+0.01);
    g.gain.exponentialRampToValueAtTime(0.0001,audioCtx.currentTime+0.35);
    o.connect(g); g.connect(masterGain); o.start(); o.stop(audioCtx.currentTime+0.36);
  }catch(e){}
}
function updateDroneEnergy(avg){
  if(!audioReady||!audioEnabled||!masterGain) return;
  masterGain.gain.setTargetAtTime(0.4+avg*0.3,audioCtx.currentTime,2.0);
}
document.getElementById('audio-prompt').addEventListener('click',()=>{ if(audioEnabled) disableAudio(); else enableAudio(); });

// ─── Draw strands (3D projected, depth-sorted) ────────────────────────────────
// We collect projected segments, sort by depth, then draw back-to-front
function drawStrands(){
  const segments=[];
  for(let s of strands){
    if(s.nodes.length<2) continue;
    const tip=s.tip();
    const tipP=project(tip.x,tip.y,tip.z);
    const mw=(tipP&&mouseX>0)?Math.max(0,1-dist2D(tipP.sx,tipP.sy,mouseX,mouseY)/130):0;
    const e=Math.min(1,s.energy+mw*0.45);

    for(let i=1;i<s.nodes.length;i++){
      const a=s.nodes[i-1], b=s.nodes[i];
      const pa=project(a.x,a.y,a.z);
      const pb=project(b.x,b.y,b.z);
      if(!pa||!pb) continue;
      const avgDepth=(pa.depth+pb.depth)*0.5;
      segments.push({pa,pb,e,thickness:s.thickness,depth:avgDepth,alive:s.alive,isTip:i===s.nodes.length-1});
    }
  }

  // Sort back to front (higher depth = further, draw first)
  segments.sort((a,b)=>b.depth-a.depth);

  for(let seg of segments){
    const {pa,pb,e,thickness,depth} = seg;
    const fog=depthFog(depth);
    const ef=e*fog;
    // Clamp scale — objects very close to camera can have huge scale values
    const scale=Math.max(0.05, Math.min(6, (pa.scale+pb.scale)*0.5));

    ctx.lineWidth=Math.min(30, thickness*(0.4+e*0.9)*scale);
    ctx.lineCap='round'; ctx.lineJoin='round';

    let r,g,b,a;
    if(ef>0.55){ r=55+ef*85; g=185+ef*65; b=135+ef*90; a=(0.5+ef*0.35)*fog; }
    else if(ef>0.3){ r=38+ef*55; g=130+ef*85; b=75+ef*105; a=(0.25+ef*0.32)*fog; }
    else { r=45+ef*38; g=72+ef*55; b=25+ef*38; a=(0.08+ef*0.18)*fog; }

    ctx.strokeStyle=`rgba(${r|0},${g|0},${b|0},${a})`;
    const blur=Math.min(40,(5+ef*14)*scale);
    if(ef>0.45&&fog>0.4&&isFinite(blur)){ ctx.shadowColor=`rgba(${r|0},${g|0},${b|0},${(ef-0.35)*0.5*fog})`; ctx.shadowBlur=blur; }
    else ctx.shadowBlur=0;

    ctx.beginPath(); ctx.moveTo(pa.sx,pa.sy); ctx.lineTo(pb.sx,pb.sy); ctx.stroke();
    ctx.shadowBlur=0;

    // Tip dot
    if(seg.alive&&seg.isTip&&ef>0.22){
      const dotR=Math.min(20,(1.2+ef*2.2)*scale);
      const tipBlur=Math.min(40,(6+ef*11)*scale);
      if(isFinite(pb.sx)&&isFinite(pb.sy)&&dotR>0){
        ctx.beginPath(); ctx.arc(pb.sx,pb.sy,dotR,0,Math.PI*2);
        ctx.fillStyle=`rgba(${r|0},${g|0},${b|0},${a*1.5})`;
        if(isFinite(tipBlur)){ ctx.shadowColor=`rgba(${r|0},${g|0},${b|0},${0.8*fog})`; ctx.shadowBlur=tipBlur; }
        ctx.fill(); ctx.shadowBlur=0;
      }
    }
  }
}

function drawAnts(){
  // Sort ants back-to-front by projected depth
  const antProj=ants.map(a=>{
    const p=project(a.x,a.y,a.z);
    return {ant:a, p, depth:p?p.depth:9999};
  }).filter(ap=>ap.p).sort((a,b)=>b.depth-a.depth);

  for(let {ant:a,p} of antProj){
    const fog=depthFog(p.depth);
    if(fog<0.05) continue;
    // Skip if projected position is wildly off screen
    if(p.sx<-200||p.sx>W+200||p.sy<-200||p.sy>H+200) continue;
    const sc=Math.max(0.05, Math.min(8, p.scale)); // clamp scale
    try {
    ctx.save();
    ctx.translate(p.sx,p.sy);
    ctx.rotate(a.angle);
    ctx.scale(sc,sc);
    ctx.globalAlpha=fog;
    // Abdomen
    ctx.beginPath(); ctx.ellipse(-3.2,0,2.8,2.1,0,0,Math.PI*2);
    ctx.fillStyle='rgba(175,95,18,0.9)'; ctx.fill();
    // Thorax
    const bg=ctx.createRadialGradient(0,0,0,0,0,3.2);
    bg.addColorStop(0,'rgba(255,195,65,0.95)'); bg.addColorStop(0.55,'rgba(205,135,32,0.88)'); bg.addColorStop(1,'rgba(130,65,12,0)');
    ctx.fillStyle=bg; ctx.beginPath(); ctx.ellipse(0,0,3.2,2,0,0,Math.PI*2); ctx.fill();
    // Head
    ctx.beginPath(); ctx.arc(3.8,0,1.9,0,Math.PI*2); ctx.fillStyle='rgba(225,165,45,0.92)'; ctx.fill();
    // Legs
    ctx.strokeStyle='rgba(195,138,28,0.5)'; ctx.lineWidth=0.65;
    for(let l=0;l<3;l++){
      const lx=(l-1)*2.2, phase=l*1.1;
      ctx.beginPath(); ctx.moveTo(lx,-1.8); ctx.lineTo(lx+Math.sin(a.wobble+phase)*2.5,-7+Math.cos(a.wobble+phase)*1.5); ctx.stroke();
      ctx.beginPath(); ctx.moveTo(lx,1.8);  ctx.lineTo(lx-Math.sin(a.wobble+phase)*2.5, 7-Math.cos(a.wobble+phase)*1.5); ctx.stroke();
    }
    // Antennae
    ctx.beginPath();
    ctx.moveTo(4.8,-0.4); ctx.quadraticCurveTo(8.5,-3.5,11,-7+Math.sin(a.wobble*0.5));
    ctx.moveTo(4.8,0.4);  ctx.quadraticCurveTo(8.5,3.5, 11, 7-Math.sin(a.wobble*0.5));
    ctx.strokeStyle='rgba(200,140,30,0.45)'; ctx.lineWidth=0.55; ctx.stroke();
    // Leaf
    if(a.hasLeaf) drawLeaf(ctx,a.leafVariant,7.5,-4,a.leafAngle,0.82*fog);
    ctx.globalAlpha=1;
    ctx.restore();
    } catch(e){} // skip bad frames gracefully
  }
}

function drawSpores(){
  for(let sp of spores){
    const p=project(sp.x,sp.y,sp.z); if(!p) continue;
    if(!isFinite(p.sx)||!isFinite(p.sy)) continue;
    const fog=depthFog(p.depth);
    const e=sp.life*fog;
    const sc=Math.max(0.05, Math.min(6, p.scale));
    const r=Math.max(0.1, sp.r*e*sc);
    if(!isFinite(r)) continue;
    ctx.beginPath(); ctx.arc(p.sx,p.sy,r,0,Math.PI*2);
    ctx.fillStyle=`rgba(${sp.hue},${e*0.75})`;
    const sblur=Math.min(30,(3+e*7)*sc);
    if(isFinite(sblur)){ ctx.shadowColor=`rgba(${sp.hue},${e*0.5})`; ctx.shadowBlur=sblur; }
    ctx.fill(); ctx.shadowBlur=0;
  }
}

// ─── Hint fade ──────────────────────────────────────────────────────────────────
let hintFaded=false;
setTimeout(()=>{
  const h=document.getElementById('tilt-hint');
  h.style.opacity='0'; hintFaded=true;
}, 6000);

// ─── Main loop ──────────────────────────────────────────────────────────────────
let tick=0, lastSpawn=0;

function loop(){
  requestAnimationFrame(loop);
  tick++;

  // Smooth camera
  camRotX+=(targetRotX-camRotX)*0.08;
  camRotY+=(targetRotY-camRotY)*0.08;

  // Grow
  for(let s of strands) if(s.alive) s.grow();

  // Prune
  if(strands.length>MAX_STRANDS+100){
    let p=0;
    for(let i=strands.length-1;i>=0&&p<25;i--)
      if(!strands[i].alive){ strands.splice(i,1); p++; }
  }

  // Spawn
  const spawnInterval=Math.max(20,50/epochGrowthRate)|0;
  if(tick-lastSpawn>spawnInterval&&strands.filter(s=>s.alive).length<MAX_STRANDS*0.72){
    spawnStrand(); lastSpawn=tick;
  }

  // Mouse warm (unproject mouse to nearest Z=0 plane)
  for(let s of strands){
    const t=s.tip();
    const p=project(t.x,t.y,t.z); if(!p) continue;
    const md=dist2D(p.sx,p.sy,mouseX,mouseY);
    if(md<110) s.energy=Math.min(1,s.energy+0.0025*(1-md/110));
  }

  // Ants
  for(let a of ants) a.update(tick);

  // Spores
  for(let i=spores.length-1;i>=0;i--){ spores[i].update(); if(spores[i].life<=0) spores.splice(i,1); }

  // Pheromone decay
  for(let i=pheromones.length-1;i>=0;i--){
    pheromones[i].str*=0.982;
    if(pheromones[i].str<0.04) pheromones.splice(i,1);
  }

  // Energy decay
  for(let s of strands) if(!s.alive) s.energy*=0.9998;

  // Pheromone canvas fade
  if(tick%2===0) fadePheroCanvas();

  // Audio
  if(tick%40===0){
    const alive=strands.filter(s=>s.alive);
    const avg=alive.length>0?alive.reduce((s,x)=>s+x.energy,0)/alive.length:0.3;
    updateDroneEnergy(avg);
  }

  // ── Draw ──
  ctx.fillStyle='rgba(8,6,3,0.17)';
  ctx.fillRect(0,0,W,H);

  drawStrands();
  drawSpores();
  drawAnts();

  // Violet bloom
  if(tick%200<4){
    const bx=Math.random()*W,by=Math.random()*H;
    const bg=ctx.createRadialGradient(bx,by,0,bx,by,50+Math.random()*100);
    bg.addColorStop(0,'rgba(90,35,150,0.055)'); bg.addColorStop(1,'rgba(0,0,0,0)');
    ctx.fillStyle=bg; ctx.fillRect(0,0,W,H);
  }

  // Draw tilt indicator when tilted
  if(Math.abs(camRotX)>0.02||Math.abs(camRotY)>0.02){
    const tiltMag=Math.sqrt(camRotX*camRotX+camRotY*camRotY)/MAX_TILT;
    ctx.save();
    ctx.strokeStyle=`rgba(150,130,70,${tiltMag*0.25})`;
    ctx.lineWidth=0.5;
    // Horizon line to reinforce tilt feeling
    const horizY=H/2+camRotX*H*0.4;
    ctx.beginPath(); ctx.moveTo(0,horizY); ctx.lineTo(W,horizY);
    ctx.stroke();
    ctx.restore();
  }
}

// ─── Init ────────────────────────────────────────────────────────────────────────
window.addEventListener('resize',()=>{ resize(); });
resize();
loop();

})();
</script>
</body>
</html>
